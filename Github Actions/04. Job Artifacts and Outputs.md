# Job Artifacts and Outputs

## Job Artifacts

### Overview of Job Artifacts

In many workflows, jobs produce assets or outputs that need to be shared or analyzed by other parts of the workflow or even external systems. These assets are referred to as "Job Artifacts." Job Artifacts are files or directories generated by a job, and they serve various purposes, such as sharing log files, storing compiled binaries, archiving build artifacts, and more.

### Use Cases for Job Artifacts

Here are some common use cases for Job Artifacts:

1. **Sharing Compiled Binaries:** After a build job, you may want to share the resulting binary files, such as an application executable or library, with other jobs or external systems.

2. **Archiving Log Files:** Jobs often generate log files containing valuable information about the build or test process. These log files can be archived as artifacts for further analysis or debugging.

3. **Storing Configuration Files:** Configuration files required for deployment or runtime settings can be generated by a job and stored as artifacts for use in subsequent steps or jobs.

### Uploading and Downloading Job Artifacts

GitHub Actions provides actions that allow you to upload and download Job Artifacts easily. Two key actions for working with Job Artifacts are `actions/upload-artifact` and `actions/download-artifact`.

#### Uploading Job Artifacts

To upload artifacts from a job, you can use the `actions/upload-artifact` action. Here's an example of how to use it in a workflow:

```yaml
name: Deploy website
on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    # Build your project here

    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: my-artifact
        path: |
          dist
          package.json
```

In this example, the `actions/upload-artifact` action is used to upload artifacts from the `dist` directory and the `package.json` file.

#### Downloading Job Artifacts

To download artifacts in another job, you can use the `actions/download-artifact` action. Here's an example of how to use it:

```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Download artifacts
      uses: actions/download-artifact@v3
      with:
        name: my-artifact

    # Use the downloaded artifacts in your deployment process
```

In this example, the `actions/download-artifact` action is used to retrieve the previously uploaded artifacts named `my-artifact`.

### Manual Access to Job Artifacts

Besides programmatic access through GitHub Actions, you can manually access and download artifacts via the GitHub UI or the GitHub REST API. This allows users to interact with artifacts directly from the GitHub repository.

## Job Outputs

### Overview of Job Outputs

In addition to Job Artifacts, GitHub Actions also provides a mechanism for jobs to produce and share simple values known as "Job Outputs." Job Outputs are useful for passing information between different steps within the same job or between different jobs within a workflow. These values can be set and retrieved using the `::set-output` command.

### Use Cases for Job Outputs

Job Outputs are typically used when you need to:

1. **Share Data Between Steps:** Pass data between different steps within the same job to coordinate their actions. For example, you can use Job Outputs to store the path of a generated file and then use that path in a subsequent step.

2. **Share Data Between Jobs:** Pass data between different jobs within a workflow. This is useful when you want to use the result of one job in another job, such as sharing the name of a file generated in a previous build step.

### Setting and Retrieving Job Outputs

Let's explore how to set and retrieve Job Outputs in a GitHub Actions workflow.

#### Setting Job Outputs

To set a Job Output, you can use the `::set-output` command within a step. Here's an example:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Generate a file
      run: |
        # Perform some actions to generate a file
        touch generated-file.txt

      # Set the 'script-file' output to the path of the generated file
      # You can use '::set-output name=<output-name>::<output-value>' syntax
      # In this case, 'script-file' is the output name, and 'generated-file.txt' is the output value
      shell: bash
      continue-on-error: true
      if: always()
      run: echo "::set-output name=script-file::generated-file.txt"
```

In this example, a Job Output named `script-file` is set to the value `generated-file.txt`.

#### Retrieving Job Outputs

To retrieve a Job Output in a subsequent step or job, you can use the `steps` context and the `needs` context.

Here's how to retrieve and use a Job Output from a previous step:

```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Build and Deploy
      run: |
        # Deploy the application using the 'script-file' output from the 'build' job
        file_path=$(cat ${{ needs.build.outputs.script-file }})
        # Use the file_path variable as needed in your deployment process
```

In this example, the `needs.build.outputs.script-file` expression is used to retrieve the value of the `script-file` Job Output from the `build` job.

### Use Case Example: Sharing File Paths

Let's illustrate a practical use case for Job Outputs. Suppose you have a build job that generates a JavaScript file, and you want to pass the path of this file to a deployment job. Here's how you can achieve this:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Build JavaScript
      run: |
        # Build your JavaScript code
        # Assuming the output file is 'app.js'
        touch app.js

      # Set the 'js-file' output to the path of the generated JavaScript file
      run: echo "::set-output name=js-file::app.js"

  deploy:
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Deploy JavaScript
      run: |
        # Retrieve the path of the JavaScript file from the 'build' job output
        js_path=${{ needs.build.outputs.js-file }}
        # Use the js_path variable as needed in your deployment process
```

In this example, the path of the generated JavaScript file is set as a Job Output in the `build` job and then retrieved in the `deploy` job for deployment.

## Caching Dependencies

### Overview of Caching Dependencies

Caching is a crucial feature in GitHub Actions that helps speed up workflows, especially when dealing with dependencies that don't change frequently. Caching allows you to store and reuse certain files or directories between workflow runs, reducing the need to download or recreate them every time a workflow is triggered.

While caching is a powerful tool, it's essential to understand when and how to use it effectively. Caching is primarily used for dependencies, such as package managers, build artifacts, or any files and folders that can be reused across workflow runs. However, it's important to note that caching should not be used for Job Artifacts, which are better managed separately.

### Use Cases for Caching Dependencies

Here are some common use cases for caching dependencies in GitHub Actions:

1. **Package Manager Dependencies:** Caching package manager dependencies like npm, pip, or composer can significantly reduce workflow execution time, especially for large projects with numerous dependencies.

2. **Build Artifacts:** If your workflow involves a build step that generates artifacts, you can cache these artifacts to avoid rebuilding them from scratch in every run.

3. **Third-party Dependencies:** Dependencies fetched from external sources, such as Docker images or external API responses, can be cached to reduce external requests.

### Caching with `actions/cache`

GitHub Actions provides the `actions/cache` action, which simplifies the process of caching dependencies. This action automatically stores and updates cache values based on a cache key that you specify. The cache key can be a combination of factors, such as the version of your code, the package manager configuration, or any other criteria that determine the cache's validity.

Here's an example of how to use the `actions/cache` action to cache npm dependencies in a Node.js project:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: 14

    - name: Cache npm dependencies
      uses: actions/cache@v2
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-
    
    - name: Install dependencies
      run: npm install

    # Build and test your project
```

In this example, the `actions/cache` action is used to cache npm dependencies based on the cache key, which includes the operating system, Node.js version, and a hash of the `package-lock.json` file. If the cache key matches an existing cache, the dependencies are restored from the cache, saving time on dependency installation.

### Important Considerations for Caching

While caching can significantly improve workflow performance, there are some important considerations to keep in mind:

1. **Cache Keys:** Choose cache keys carefully to ensure that the cache is invalidated when necessary. A good cache key should take into account the factors that affect the validity of the cache, such as code changes or configuration updates.

2. **Cache Size:** Be mindful of the size of your cached dependencies. Caches that are too large can slow down the caching process and consume storage space in GitHub's infrastructure.

3. **Cache Miss Handling:** Plan for handling cache misses, which occur when the cache key doesn't match any existing cache. In such cases, you should be prepared to install dependencies or rebuild artifacts from scratch.

4. **Cache Retention Policy:** GitHub Actions automatically manages the retention of cached items. However, it's a good practice to periodically review and adjust your caching strategy to ensure it aligns with your workflow requirements.

## Full Example with Artifacts, Outputs, Caching

```yaml
name: Show how to use Artifacts.

# Specify when the workflow should be triggered
on:
  push:
    branches:
      - master
  workflow_dispatch:

# Define the jobs in the workflow
jobs:
  # Job for testing and linting
  test-and-lint:
    runs-on: ubuntu-latest
    outputs:
      CACHE_PATH_OUTPUT: ${{ steps.cache_path.outputs.CACHE_PATH }}
    steps:
      # Checkout the repository
      - name: Checkout
        uses: actions/checkout@v4

      # Set up Node.js environment
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 14
      # Cache the Path into Outputs.
      - name: Setup Cache Path
        id: cache_path
        # Here, the "CACHE_PATH" key name will be added into GITHUB_OUTPUT,
        # and we can link it in jobs.test-and-lint.outputs.CACHE_PATH_OUTPUT,
        # then we can use it in another jobs or steps by ${{ needs.test-and-lint.outputs.CACHE_PATH_OUTPUT }}
        run: |
          echo 'CACHE_PATH=deps-node-modules-${{ hashFiles('**/package-lock.json') }}' >> $GITHUB_OUTPUT
      # Cache dependencies to speed up workflow
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ steps.cache_path.outputs.CACHE_PATH }}

      # Install project dependencies
      - name: Install Dependencies
        run: |
          npm install

      # Lint and run unit tests
      - name: Lint And Test
        run: |
          npm run lint
          npm run test:unit

  # Job for building the project
  build:
    needs:
      - test-and-lint
    runs-on: ubuntu-latest
    steps:
      # Checkout the repository
      - name: Checkout
        uses: actions/checkout@v4

      # Set up Node.js environment
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 14

      # Cache dependencies to speed up workflow
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ needs.test-and-lint.outputs.CACHE_PATH_OUTPUT }}

      # Install project dependencies
      - name: Install Dependencies
        run: |
          npm install

      # Build the project
      - name: Build
        run: |
          npm run build

      # Upload build artifacts
      - name: Upload Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: my-static-files
          # if you only have one file or directory to upload, you can do like this: "path: dist", without "|"
          path: |
            dist

  # Job for deploying the project
  deploy:
    needs:
      - build
    runs-on: ubuntu-latest
    steps:
      # Checkout the repository
      - name: Checkout
        uses: actions/checkout@v4

      # Download build artifacts
      - name: Download Artifacts
        uses: actions/download-artifact@v3
        with:
          name: my-static-files
          path: ./dist/

      # Deploy (DRY-RUN) - Print file information
      - name: Deploy(DRY-RUN)
        run: |
          # Find and print files in the dist directory
          find ./dist/ -type f -printf "Uploading %f to S3 bucket...\n"

```

## Conclusion

GitHub Actions provides powerful features for managing workflow automation, and understanding Job Artifacts, Job Outputs, and Caching Dependencies is essential for creating efficient and reliable workflows. Job Artifacts allow you to share and store assets generated by jobs, Job Outputs enable the exchange of values between steps and jobs, and caching helps optimize workflow performance by storing and reusing dependencies.

By mastering these GitHub Actions concepts, you can create workflows that streamline your software development and deployment processes, making your development pipeline more efficient and reliable. As you continue to explore GitHub Actions, consider how these features can be applied to your specific projects and use cases to maximize their benefits.

## References:
[GitHub Actions: Deprecating save-state and set-output commands](https://github.blog/changelog/2022-10-11-github-actions-deprecating-save-state-and-set-output-commands/)
[Environment Files](https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#environment-files)
