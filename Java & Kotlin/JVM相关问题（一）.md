---
title: JVM相关问题（一）
url: https://www.yuque.com/stevenyin/liv/mkhqvu
---

<a name="h4lkX"></a>

## **JVM调优**

- 查看堆空间大小分配（年轻代、年老代、持久代分配）
- 垃圾回收监控（长时间监控回收情况）
- 线程信息监控：系统线程数量
- 线程状态监控：各个线程都处在什么样的状态下
- 线程详细信息：查看线程内部运行情况，死锁检查
- CPU热点：检查系统哪些方法占用了大量CPU时间
- 内存热点：检查哪些对象在系统中数量最大 <a name="JHqUu"></a>

## Minor GC ，Full GC 触发条件

Minor GC触发条件：当Eden区满时，触发Minor GC。
Full GC触发条件：
（1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）方法区空间不足
（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
（5）由Eden区、From Space区向To Sp3ace区复制时，对象大小大于To Space可存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 <a name="uvfcf"></a>

## JVM内存调优

对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。 过多的GC和Full GC是会占用很多的系统资源（主要是CPU），影响系统的吞吐量。
使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。
1）监控GC的状态，使用各种JVM工具，查看当前日志，并且分析当前堆内存快照和gc日志，根据实际的情况看是否需要优化。
2）通过JMX的MBean或者Java的jmap生成当前的Heap信息，并使用Visual VM或者Eclipse自带的Mat分析dump文件
3）如果参数设置合理，没有超时日志，GC频率GC耗时都不高则没有GC优化的必要，如果GC时间超过1秒或者频繁GC，则必须优化
4）调整GC类型和内存分配，使用1台和多台机器进行测试，进行性能的对比。再做修改，最后通过不断的试验和试错，分析并找到最合适的参数 <a name="y7JiA"></a>

## 如何判断是否有内存泄露？

泄露可以对比不同时间点内存分配，一般看用户类型的分配情况，什么在增加。具体，比如用jmap -histo:live 多次快照，然后对比差异，或者用jmc之类profiling工具，都可以进行，对比会更加流畅一些 <a name="cj3fq"></a>

## **定位 Full GC 发生的原因，有哪些方式？**

1. 首先通过`printgcdetail` 查看`fullgc`频率以及时长
2. 通过dump 查看内存中哪些对象多，这些可能是引起fullgc的原因，看是否能优化
3. 如果堆大或者是生产环境，可以开起jmc 飞行一段时间，查看这期间的相关数据来订位问题 <a name="eGa9K"></a>

## Java 中都有哪些引用类型？

强引用：发生 gc 的时候不会被回收。 `new`
软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。`SoftReference`
弱引用：有用但不是必须的对象，在下一次GC时会被回收。`WeakReference`
虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 `PhantomReference` 实现虚引用，虚引用的用途是在 gc 时返回一个通知。
`PhantomReference pr = new PhantomReference (object, queue);`

<a name="FJPYH"></a>

## **OOM？怎么排查？哪些会导致OOM? OOM出现在什么时候**

OOM，全称“Out Of Memory”，官方说明：当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error。（没有空闲内存，并且垃圾收集器也无法提供更多内存。） <a name="Qd8nJ"></a>

### 怎么排查？

首先可以查看服务器运行日志以及项目记录的日志，捕捉到内存溢出异常。
核心系统日志文件 <a name="SDm3l"></a>

### **OOM出现在什么时候？哪些会导致OOM?**

java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设。置不当引起。 可以通过虚拟机参数-Xms,-Xmx等修改。
（1）java永久代溢出，即方法区溢出了，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见 ，尤其是在运行时存在大量动态类型生成的场合；（JDK8 已经没有方法区了，改为元数据区）
（2）JAVA虚拟机栈溢出，不会抛OOM error，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。
（３）直接内存不足，也会导致 OOM <a name="fcIrV"></a>

## **JVM中类加载机制，类加载过程，什么是双亲委派模型？ 类加载器有哪些**

一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java 虚拟机规范里有非常详细的定义。
首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。
加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。
第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：
验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。
准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。
解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。
最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。 <a name="be0ia"></a>

### 双亲委派模型

再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。 <a name="oj1DM"></a>

### 类加载器有哪些

1.启动类加载器：加载 jre/lib 下面的 jar 文件
2.扩展类加载器，负责加载我们放到 jre/lib/ext/ 目录下面的 jar 包，
3.应用类加载器（Application or App Class-Loader），就是加载我们最熟悉的 classpath 的内容。
